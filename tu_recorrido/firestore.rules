rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // --- FUNCIONES GLOBALES ---
    function isAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }

    function isEmailVerified() {
      return request.auth.token.email_verified == true;
    }

    // Función para verificar si un usuario es administrador
    function isAdmin() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Función para validar el valor del rating
    function isValidRating() {
      return request.resource.data.rating is number &&
             request.resource.data.rating >= 0 &&
             request.resource.data.rating <= 5;
    }

    // Función para verificar si el usuario sigue a otro usuario
    function isFollowing(targetUserId) {
      return exists(/databases/$(database)/documents/following/$(request.auth.uid)/following/$(targetUserId));
    }

    // --- COLECCIÓN: USERS ---
    match /users/{uid} {
      // Reglas básicas (Lectura/Escritura)
      // Lectura: Cualquier usuario autenticado puede leer perfiles
      // (la privacidad se maneja en la capa de aplicación basándose en isPublic)
      allow read: if isAuthenticated();
      allow delete: if request.auth != null && request.auth.uid == uid;

      // Validación de esquema para el documento user
      function isValidUser(data) {
        return
          (data.keys().hasOnly([
            'uid','email','displayName','photoURL','backgroundURL','nombre','apodo',
            'fechaNacimiento','region','comuna','activo','createdAt','updatedAt','role',
            'followersCount','followingCount','badgesCount','placesVisitedCount',
            'isPublic','showBadges','showAlbum'
          ])) &&
          (data.uid is string) &&
          (data.email is string) &&
          (data.displayName is string || data.displayName == null) &&
          (data.photoURL is string || data.photoURL == null) &&
          (data.backgroundURL is string || data.backgroundURL == null) &&
          (data.nombre is string || data.nombre == null) &&
          (data.apodo is string || data.apodo == null) &&
          (data.fechaNacimiento is string || data.fechaNacimiento == null) &&
          (data.region is string || data.region == null) &&
          (data.comuna is string || data.comuna == null) &&
          (data.activo is bool || data.activo == null) &&
          (data.role is string || data.role == null) &&
          // Nuevos campos sociales
          (data.get('followersCount', 0) is number) &&
          (data.get('followingCount', 0) is number) &&
          (data.get('badgesCount', 0) is number) &&
          (data.get('placesVisitedCount', 0) is number) &&
          (data.get('isPublic', true) is bool) &&
          (data.get('showBadges', true) is bool) &&
          (data.get('showAlbum', true) is bool);
      }

      // Función para validar actualizaciones parciales
      function isValidPartialUpdate() {
        let allowedKeys = ['nombre', 'apodo', 'displayName', 'photoURL', 'backgroundURL', 'region', 'comuna', 'updatedAt', 'isPublic', 'showBadges', 'showAlbum', 'followersCount', 'followingCount', 'badgesCount', 'placesVisitedCount'];
        let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
        return affectedKeys.hasOnly(allowedKeys);
      }

      // Función para validar actualización solo de contadores sociales
      function isValidSocialCountersUpdate() {
        let allowedKeys = ['followersCount', 'followingCount', 'badgesCount', 'placesVisitedCount', 'updatedAt'];
        let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
        return affectedKeys.hasOnly(allowedKeys);
      }

      // Creación: Sólo el propio usuario puede crearse y debe pasar validación
      allow create: if isAuthenticated()
                       && request.auth.uid == uid
                       && isValidUser(request.resource.data);

      // Actualización: Debe pasar validación y ser dueño o admin.
      allow update: if isAuthenticated()
                       && (
                         // Actualización completa del documento
                         (isValidUser(request.resource.data) && 
                          (
                            // DUEÑO: Puede actualizar su perfil, PERO no cambiar el 'role' (o establecerlo como null)
                            (request.auth.uid == uid &&
                             (request.resource.data.role == resource.data.role || request.resource.data.role == null))
                            // ADMIN: Puede cambiar todo
                            || isAdmin()
                          )
                          // No permitir que el cliente cambie 'createdAt'
                          && (request.resource.data.createdAt == resource.data.createdAt))
                         // O actualización parcial de campos permitidos (solo el dueño)
                         || (request.auth.uid == uid && isValidPartialUpdate() && !('role' in request.resource.data.diff(resource.data).affectedKeys()))
                         // O actualización de contadores sociales (cualquier usuario autenticado)
                         || isValidSocialCountersUpdate()
                       );


      // --- SUBCOLECCIÓN: estaciones_visitadas ---
      match /estaciones_visitadas/{estacionVisitadaId} {
        // Validación de esquema para estaciones visitadas
        function isValidEstacionVisitada(data) {
          return
            (data.keys().hasOnly([
              'id', 'estacionId', 'estacionCodigo', 'estacionNombre',
              'fechaVisita', 'latitudVisita', 'longitudVisita'
            ])) &&
            (data.id is string) &&
            (data.estacionId is string) &&
            (data.estacionCodigo is string) &&
            (data.estacionNombre is string) &&
            (data.fechaVisita is timestamp) &&
            (data.latitudVisita is number || data.latitudVisita == null) &&
            (data.longitudVisita is number || data.longitudVisita == null);
        }

        // Lectura: Cualquier usuario autenticado puede leer (privacidad en app)
        // Escritura: Solo el dueño
        allow read: if isAuthenticated();
        allow create: if isAuthenticated()
                       && request.auth.uid == uid
                       && isValidEstacionVisitada(request.resource.data);

        allow update: if isAuthenticated()
                       && request.auth.uid == uid
                       && isValidEstacionVisitada(request.resource.data);
        
        allow delete: if isAuthenticated() && request.auth.uid == uid;
      }

      // --- SUBCOLECCIÓN: insignias ---
      match /insignias/{insigniaId} {
        // Validación simple para el documento de insignia del usuario
        function isValidUserInsignia(data) {
          return (
            data.keys().hasOnly(['fechaObtenida']) ||
            data.keys().hasOnly(['fechaObtenida','estacionRef'])
          )
          && (data.fechaObtenida is timestamp);
        }

        // Lectura: Cualquier usuario autenticado puede leer (privacidad en app)
        // Escritura: dueño o admin
        allow read: if isAuthenticated();

        // Crear: dueño o admin, y debe pasar validación de esquema
        allow create: if isAuthenticated()
                       && (request.auth.uid == uid || isAdmin())
                       && isValidUserInsignia(request.resource.data);

        // Update/Delete: dueño o admin
        allow update, delete: if isAuthenticated() && (request.auth.uid == uid || isAdmin());
      }

      // --- SUBCOLECCIÓN: album_photos ---
      match /album_photos/{photoId} {
        // Validación de esquema para fotos del álbum
        function isValidAlbumPhoto(data) {
          return
            (data.keys().hasOnly([
              'id', 'badgeId', 'imageUrl', 'thumbnailUrl', 'description',
              'uploadDate', 'location', 'metadata'
            ])) &&
            (data.id is string) &&
            (data.badgeId is string) &&
            (data.imageUrl is string) &&
            (data.thumbnailUrl is string || data.thumbnailUrl == null) &&
            (data.description is string || data.description == null) &&
            (data.uploadDate is timestamp) &&
            (data.location is string || data.location == null) &&
            (data.metadata is map || data.metadata == null);
        }

        // Lectura: Cualquier usuario autenticado puede leer (privacidad en app)
        // Escritura: Solo el dueño
        allow read: if isAuthenticated();

        allow create: if isAuthenticated()
                       && request.auth.uid == uid
                       && isValidAlbumPhoto(request.resource.data);

        allow update: if isAuthenticated()
                       && request.auth.uid == uid
                       && isValidAlbumPhoto(request.resource.data);

        allow delete: if isAuthenticated() && request.auth.uid == uid;
      }

      // ----- FOTOS DEL ÁLBUM (subcollection) -----
      match /album_photos/{photoId} {
        // Validación de esquema para fotos del álbum
        function isValidAlbumPhoto(data) {
          return
            (data.keys().hasOnly([
              'id', 'badgeId', 'imageUrl', 'thumbnailUrl', 'description',
              'uploadDate', 'location', 'metadata'
            ])) &&
            (data.id is string) &&
            (data.badgeId is string) &&
            (data.imageUrl is string) &&
            (data.thumbnailUrl is string || data.thumbnailUrl == null) &&
            (data.description is string || data.description == null) &&
            (data.uploadDate is timestamp) &&
            (data.location is string || data.location == null) &&
            (data.metadata is map || data.metadata == null);
        }

        // Solo el dueño puede leer/escribir sus fotos del álbum con validación
        allow read: if request.auth != null && request.auth.uid == uid;
        allow create: if request.auth != null 
                      && request.auth.uid == uid 
                      && isValidAlbumPhoto(request.resource.data);
        allow update: if request.auth != null 
                      && request.auth.uid == uid 
                      && isValidAlbumPhoto(request.resource.data);
        allow delete: if request.auth != null && request.auth.uid == uid;
      }
    }
  // ----- PLACES (legacy) -----
    // Mantener reglas para compatibilidad con documentos históricos bajo 'places'.
    match /places/{placeId} {
      allow read: if true;
      allow create, update, delete: if request.auth != null;
    }

    // --- COLECCIÓN: INSIGNIAS (top-level) ---
    match /insignias/{insigniaId} {
      function isValidInsignia(data) {
        return data.keys().hasOnly(['nombre','descripcion','imagenUrl','fechaCreacion'])
               && (data.nombre is string)
               && (data.descripcion is string)
               && (data.imagenUrl is string)
               && (data.fechaCreacion is timestamp);
      }

      // Lectura: cualquiera autenticado puede leer la lista de insignias
      allow read: if isAuthenticated();

      // Crear/Actualizar/Borrar: solo administradores
      allow create: if isAdmin() && isValidInsignia(request.resource.data);
      allow update, delete: if isAdmin();
    }

    // ----- ESTACIONES -----
    // Estaciones patrimoniales para escaneo QR
    match /estaciones/{estacionId} {
      // Lectura pública para usuarios autenticados (escaneo QR)
      allow read: if isAuthenticated();

      // Solo administradores pueden crear/actualizar/borrar estaciones
      allow create, update, delete: if isAdmin();

      // Validación de esquema para estaciones
      // Aceptamos un conjunto amplio de campos (legacy y actuales) y validamos
      // tipos de forma tolerante usando `get(key, default)`.
      function isValidEstacion(data) {
        let allowedKeys = [
          'codigo', 'codigoQR', 'nombre', 'descripcion',
          'latitud', 'longitud', 'fechaCreacion', 'createdAt', 'activa',
          'insigniaID', 'rating', 'totalRatings', 'updatedAt',
          'imagenes', 'comuna', 'lat', 'lng', 'badgeImage'
        ];

        return data.keys().hasOnly(allowedKeys)
          && (data.get('codigo', null) is string)
          && (data.get('codigoQR', null) is string)
          && (data.get('nombre', null) is string)
          && (data.get('descripcion', null) is string)
          && ((data.get('latitud', null) is number) || (data.get('latitud', null) == null))
          && ((data.get('longitud', null) is number) || (data.get('longitud', null) == null))
          && ((data.get('fechaCreacion', null) is timestamp) || (data.get('fechaCreacion', null) == null))
          && ((data.get('activa', true) is bool) || (data.get('activa', null) == null))
          && ((data.get('rating', 0) is number) || (data.get('rating', null) == null))
          && ((data.get('totalRatings', 0) is number) || (data.get('totalRatings', null) == null))
          && ((data.get('updatedAt', null) is timestamp) || (data.get('updatedAt', null) == null))
          && ((data.get('imagenes', null) is list) || (data.get('imagenes', null) == null))
          && ((data.get('comuna', null) is string) || (data.get('comuna', null) == null));
      }

      // Validaciones para creación/actualización son responsabilidad del admin;
      // dejamos la función disponible si se necesita en Cloud Functions o cambios futuros.

      // Subcolección: ratings (mantener reglas existentes)
      match /ratings/{ratingId} {
        // Cualquiera puede ver los ratings
        allow read: if true;

        // Solo usuarios autenticados y verificados pueden crear/actualizar su propio rating
        allow create: if isAuthenticated() && isEmailVerified() &&
          ratingId == request.auth.uid &&
          request.resource.data.keys().hasAll(['rating', 'userId', 'fecha']) &&
          request.resource.data.userId == request.auth.uid &&
          isValidRating();

        allow update: if isAuthenticated() && isEmailVerified() &&
          ratingId == request.auth.uid &&
          request.resource.data.userId == request.auth.uid &&
          resource.data.userId == request.auth.uid &&
          isValidRating();

        // Solo el dueño del rating o un admin pueden borrarlo
        allow delete: if isAuthenticated() &&
          (ratingId == request.auth.uid || isAdmin());
      }
    }

    // --- COLECCIÓN: FOLLOWERS ---
    match /followers/{userId}/followers/{followerId} {
      // Validación de esquema para followers
      function isValidFollower(data) {
        return data.keys().hasOnly(['displayName', 'photoURL', 'timestamp']) &&
               (data.displayName is string) &&
               (data.photoURL is string || data.photoURL == null) &&
               (data.timestamp is timestamp);
      }

      // Lectura: Cualquiera autenticado puede ver los seguidores
      allow read: if isAuthenticated();

      // Escritura: Solo el follower puede agregarse/quitarse como seguidor
      allow create: if isAuthenticated() && 
                       request.auth.uid == followerId &&
                       isValidFollower(request.resource.data);

      allow delete: if isAuthenticated() && request.auth.uid == followerId;
    }

    // --- COLECCIÓN: FOLLOWING ---
    match /following/{userId}/following/{followingId} {
      // Validación de esquema para following
      function isValidFollowing(data) {
        return data.keys().hasOnly(['displayName', 'photoURL', 'timestamp']) &&
               (data.displayName is string) &&
               (data.photoURL is string || data.photoURL == null) &&
               (data.timestamp is timestamp);
      }

      // Lectura: Cualquiera autenticado puede ver a quién sigue un usuario
      allow read: if isAuthenticated();

      // Escritura: Solo el usuario puede agregar/quitar a alguien que sigue
      allow create: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       isValidFollowing(request.resource.data);

      allow delete: if isAuthenticated() && request.auth.uid == userId;
    }

    // --- COLECCIÓN: FEED ---
    match /feed/{userId}/items/{itemId} {
      // Validación de esquema para items del feed
      function isValidFeedItem(data) {
        return data.keys().hasAny(['type', 'userId', 'userName', 'timestamp']) &&
               (data.type is string) &&
               (data.userId is string) &&
               (data.userName is string) &&
               (data.timestamp is timestamp);
      }

      // Lectura: Solo el dueño del feed puede leer sus items
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Escritura: Sistema puede crear items (a través de Cloud Functions)
      // Por ahora, permitimos que el usuario que realiza la acción cree su item
      allow create: if isAuthenticated() && isValidFeedItem(request.resource.data);

      // Borrar: El dueño del feed puede borrar items
      allow delete: if isAuthenticated() && request.auth.uid == userId;
    }
  }
}
